# 类

## 类的基础用法

```typescript
//1. class 的基本用法 继承 和 类型约束
//2. class 的修饰符 readonly private protected public
//3. super 原理
//4. 静态方法
//5. get set
interface Options {
    el: string | HTMLElement
}

interface VueCls {
    init(): void

    options: Options
}

interface Vnode {
    tag: string
    text?: string
    props?: {
        id?: number | string
        key?: number | string | object
    }
    children?: Vnode[]
}

class Dom {
    constructor() {

    }

    private createElement(el: string): HTMLElement {
        return document.createElement(el)
    }

    protected setText(el: Element, text: string | null) {
        el.textContent = text;
    }

    protected render(createElement: Vnode): HTMLElement {
        const el = this.createElement(createElement.tag)
        if (createElement.children && Array.isArray(createElement.children)) {
            createElement.children.forEach(item => {
                const child = this.render(item)
                this.setText(child, item.text ?? null)
                el.appendChild(child)
            })
        } else {
            this.setText(el, createElement.text ?? null)
        }
        return el;
    }

}

class Vue extends Dom implements VueCls {
    options: Options

    constructor(options: Options) {
        super()
        this.options = options;
        this.init()
    }

    static version() {
        return '1.0.0'
    }

    public init() {
        let app = typeof this.options.el == 'string' ? document.querySelector(this.options.el) : this.options.el;
        let data: Vnode = {
            tag: "div",
            props: {
                id: 1,
                key: 1
            },
            children: [
                {
                    tag: "div",
                    text: "子集1",
                },
                {
                    tag: "div",
                    text: "子集2"
                }
            ]
        }
        app?.appendChild(this.render(data))
        console.log(app);

        this.mount(app as Element)
    }

    public mount(app: Element) {
        document.body.append(app)
    }
}

const v = new Vue({
    el: "#app"
})
```

## 抽象类

应用场景如果你写的类实例化之后毫无用处此时我可以把他定义为抽象类

或者你也可以把他作为一个基类-> 通过继承一个派生类去实现基类的一些方法

我们看例子

下面这段代码会报错抽象类无法被实例化

```typescript
abstract class A {
    public name: string

}

new A()
```

例子2

我们在A类定义了 getName 抽象方法但为实现

我们B类实现了A定义的抽象方法 如不实现就不报错 我们定义的抽象方法必须在派生类实现

```typescript
abstract class A {
    name: string

    constructor(name: string) {
        this.name = name;
    }

    print(): string {
        return this.name
    }

    abstract getName(): string
}

class B extends A {
    constructor() {
        super('小满')
    }

    getName(): string {
        return this.name
    }
}

let b = new B();

console.log(b.getName());
```