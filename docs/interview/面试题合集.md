# 面试题合集

## 如何判断函数的this?请说出这2个函数的执行结果

```javascript
var length = 1

function fun() {
    console.log(this.length)
}

let arr = [fun, "a", "b"]
arr[0]() //输出什么?
let fun2 = arr[0]
fun2() //输出什么?
```

此时的`arr[0]`是fun的引用。当执行`arr[0]()`时，实际上是在arr的上下文中调用fun函 数。因为我们从数组arr中取出了一个函数，并且立即调用。
所以，此时this指向数组arr。因此第一个打印显示3，第二个等同于window.fun2()，所以第二个打印1。

## 什么是惰性函数?如何实现惰性函数?

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        element.addEventListener(type, handler, false) //Chrome和Edge
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler) //IE8 之前的旧浏览器
    } else {
        element["on" + type] = handler // 所有老版本的浏览器
    }
}
```

惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。
惰性函数的本质就是`函数重写`，所谓惰性载入，指函数执行的分支只会发生一次，正确答案如下，首次执行原有逻辑不变的同时，对原函数进行修改，下次就会跳过判断直接执行。

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        //首次执行逻辑保持不变
        element.addEventListener(type, handler, false)
        //检测到Chrome和Edge后改写
        addEvent = function (element, type, handler) {
            element.addEventListener(type, handler, false)
        }
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler)
        //检测到 IE8 之前的旧浏览器
        addEvent = function (element, type, handler) {
            element.attachEvent("on" + type, handler)
        }
    } else {
        element["on" + type] = handler
        // 检测到所有老版本的浏览器
        addEvent = function (element, type, handler) {
            element["on" + type] = handler
        }
    }
}
```

## forEach函数的原理是什么?为什么不会无限循环?

```javascript
let numbersOne = [1, 2, 3]
numbersOne.forEach((number, index) => {
    console.log(number)
    numbersOne.push("小诺")
})
console.log("会有多少小诺呢", numbersOne)
```

根据ecma规范手动实现forEach函数

```javascript
Array.prototype.xnForEach = function (callback, arg) {
    if (this === null || this === undefined) {
        throw new TypeError("this不能是null或者undefined")
    }
    let o = this
    let len = o.length
    if (typeof callback !== "function") {
        throw new TypeError("callback不是函数")
    }
    for (let k = 0; k < len; k++) {
        if (k in o) {
            let keyValue = o[k]
            callback.call(args, keyValue, k, o)
        }
    }
    return undefined
}
```

## 如何实现一个完整的发布订阅模式?

### 定义

发布订阅模式是一种常见的设计模式，在许多场景中都有应用。我们可能已经在使用中接触过发布订阅模式，比如使用 addEventListener 方法来监听 DOM 事件、Vue 的事件总线机制等。

### 实际案例

- 在 JavaScript 中，我们可以使用 DOM 2 级事件的 addEventListener 方法来订阅和监听事件。
- 在 Electron 中，使用 IpcMain 和 ipcRender 来实现主进程和渲染进程之间的事件通信。
- 在 Webpack 中，使用 Hooks 机制来订阅和处理构建过程中的各个阶段。
- 在 Vue 2 中，可以使用事件总线（Event Bus）机制来实现组件之间的通信。

### 示例代码

```typescript
interface EventFace {
    //订阅/监听
    on: (name: string, callback: Function) => void
    //发布/注册
    emit: (name: string, ...args: Array<any>) => void
    //解除绑定
    off: (name: string, fn: Function) => void
    //只执行一次
    once: (name: string, fn: Function) => void
}

interface List {
    [key: string]: Array<Function>
}

class Dispatch implements EventFace {
    list: List

    constructor() {
        this.list = {}
    }

    // 订阅事件
    on(name: string, callback: Function) {
        const callbackList: Array<Function> = this.list[name] || []
        callbackList.push(callback)
        this.list[name] = callbackList
    }

    // 发布事件
    emit(name: string, ...args: Array<any>) {
        let eventName = this.list[name]
        if (eventName) {
            eventName.forEach(fn => {
                fn.apply(this, args)
            })
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 解除绑定
    off(name: string, fn: Function) {
        let eventName = this.list[name]
        if (eventName && fn) {
            let index = eventName.findIndex(fnItem => fnItem === fn)
            eventName.splice(index, 1)
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 一次性订阅
    once(name: string, fn: Function) {
        let decorator = (...args: Array<any>) => {
            fn.apply(this, args)
            this.off(name, decorator)
        }
        this.on(name, decorator)
    }
}

const o = new Dispatch()

// 订阅事件 'abc'，输出参数
o.on('abc', (...arg: Array<any>) => {
    console.log(arg)
})

// 一次性订阅事件 'abc'，输出参数和字符串 'once'，只会触发一次
o.once('abc', (...arg: Array<any>) => {
    console.log(arg, 'once')
})

// 发布事件 'abc'，输出参数 1、小诺、小诺
o.emit('abc', 1, "小诺", "小诺")

// 再次发布事件 'abc'，输出参数  2、小诺、小诺
o.emit('abc', 2, "小诺", "小诺")
```

## ["1","2","3"].map(parseInt)的输出结果是多少?parseInt第二个参数的作用是什么?

```javascript
console.log(["1", "2", "3"].map(parseInt))
```

parseInt方法接收两个参数，第一个参数为要被解析的字符串，而已知map会传递的参数是(item,index,arr)这种结构，
因此parseInt会接收到三组数据"1" 0, "2" 1 , "3":2,parseInt第二个参数是解析数字的基数，如果不传或传0则默认
为10进制，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN，因此第二组数据返回NaN,第三组数据指定为2进制
但第一个参数确是3，不满足二进制只有0、1的条件，因此也返回NaN，所有`正确答案是[1、NaN、NaN]`

## Object.is和===有哪些区别?他们各自的判断规则是什么?

```javascript
let obj1 = {}
let obj2 = {}
console.log(obj1 == obj2)
console.log(obj1 === obj2)
console.log(Object.is(obj1, obj2))
```

### 非严格相等的隐式类型转化规则

```javascript
//特殊情况1
console.log(null == undefined) //true
//特性情况2
console.log(NaN == "xiaonuo") // false
console.log(NaN == NaN) // false
```

相等比较(==)

1.如果两个操作数类型相同，执行严格比较。

2.如果两个操作数类型不同，则进行**类型转换**后再进行比较，规则如下：

- 如果一个操作数是数值(number),另一个操作数是字符串，则将**字符串转换为数值**，然后进行比较。
- 如果一个操作数是布尔值，则将**布尔值转换为数值**，然后进行比较。
- 如果一个操作数是对象，另一个操作数是数值或字符串，则将**对象转换为原始值**，然后比较。

关于将对象转换为原始值，如果一个操作数是对象，另一个操作数是字符串或者数字，会首先调用对象的valueOf()方法，将对象转化为基本类型，再进行比较，当valueOf()返回的不是基本类型的
时候，才会调用toString()方法，示例如下。

```javascript
let obj1 = {
    valueOf() {
        return 1
    },
    toString() {
        return "2"
    }
}

console.log(obj1 == "2") //false
console.log(obj1 == 1) // true

let obj2 = {
    valueOf() {
        return {}
    },
    toString() {
        return "2"
    }
}

console.log(obj2 == "2") //true
console.log(obj2 == 1) // false

```

### Object.is 和 === 的规则

Object.is 和 === 再比较两个值时**都不会进行类型转换**

Object.is :

- 当比较NaN时，Object.is(NaN,NaN)返回true
- 当比较+0和-0时，Object.is(+0,-0)返回false,它能区分正零和负零(如果要区分正负应使用Object.is)

=== :

- NaN === NaN返回false,因为NaN是不等于任何值，包括它自己
- 对于+0和-0，+0 === -0返回true，因为**严格相等不区分正负**

## 连续赋值的计算规则是什么?这段代码的输出结果是什么

赋值的返回结果就是你赋的值

```javascript
var obj1 = {age: 18}
var obj2 = obj1
obj1.prop = obj1 = {age: 19}
console.log(obj1)//{age:19}
console.log(obj2)//{age:18,prop:{age:19}}
``` 

## 如何实现数组索引的累加?考察对Proxy对象的理解

```javascript
const obj = {sum: 0}
const add = new Proxy(obj, {
    get: function (target, prop, receiver) {
        // 如果add对象和数字相加，则把目标对象的obj的sum和数字相加
        // 如果访问add对象的索引，则把当前索引累积到sum中
        if (prop === Symbol.toPrimitive) {
            const ret = target.sum
            target.sum = 0
            return () => ret
        } else {
            const sum = (target.sum || 0) + Number(prop)
            target.sum = sum
            return receiver
        }
    }
})
//当一个对象和数字相加时，他会调用对象的toPrimitive方法，尝试将对象转化成原始类型再来相加
const result1 = add[1][2] + 3 //6
const result2 = add[3][4][5] + 6 //18

console.log(result1, result2)
```

## 求最长递增子序列(LIS)

```javascript
 function LTS(nums) {
    if (nums.length === 0) return []
    const result = [[nums[0]]]
    for (let i = 0; i < nums.length; i++) {
        const n = nums[i]
        update(n)
    }

    function update(n) {
        for (let i = result.length - 1; i >= 0; i--) {
            const line = result[i]
            const tail = line[line.length - 1]
            if (n > tail) {
                result[i + 1] = [...line, n]
                break;
            } else if (n < tail && i === 0) {
                result[i] = [n]
            }
        }
    }

    return result[result.length - 1]
}

console.log(LTS([4, 5, 1, 2, 7, 3, 6, 9]))
```

## var、let、const之间有哪些区别?你能否回答完整?

```javascript
var a = "小诺"
let b = "小诺"
const c = "小诺"
```

### 作用域不同

var声明的变量，其作用域是**全局作用域或函数作用域**，let和const是**块作用域**,块是由{}包裹起来的代码，换句话说**被一对花括号包起来的代码都属于一个块**。

::: code-group

```js [var]
var a = "小诺"
console.log(a) // 小诺

function newFunc() {
    var b = "小诺"
}

console.log(b) // b is not defined
```

```js [let、const]
let times = 4
if (times > 3) {
    var b = "小诺"
    let c = "小诺"
    console.log(b)//小诺
    console.log(c)//小诺
}
console.log(b) // 小诺
console.log(c) // c is not define
```

:::

### 声明及定义

- var变量可以更新和重新声明
- let变量可以更新不能重新声明
- const变量不能更新也不能重新声明

::: code-group

```js [var]
var x = 1
var x = 2
console.log(x) // 2
```

```js [let]
let x = 1
x = 2
console.log(x) // 2
let x = 3 //报错，变量x已经被定义
```

```js [const]
const x = 1
x = 2 //提示该变量是const变量无法修改
const x = 2 //报错，变量x已经被定义
```

:::

### 变量提升

在代码执行之前，将变量声明和函数声明提升到当前作用域的顶部，需要注意的是，只有声明会被提升，赋值操作不会被提升,而在变量提升方面，他们都被提升到了
作用域的顶部。但是var变量会被初始化为undefined，let、const不会被初始化。

::: code-group

```js [var]
console.log(x) //undefined
var x = "小诺"
console.log(x) //小诺
```

```js [let]
console.log(x) //报错，不能访问x在初始化之前
let x = "小诺"
console.log(x) //小诺
```

```js [const]
console.log(x) //报错，不能访问x在初始化之前
const x = "小诺"
console.log(x) //小诺
```

:::

## 如何访问对象的属性?点符号访问和方括号访问的区别是什么?

(.)操作符访问的是静态属性，属性名是硬编码，且在编写代码时就已知，不能使用变量作为属性名，也不能用数字作为属性名，这是因为**点表示法
要求属性名必须是一个有效的JavaScript标识符**。

方括号访问的属性是动态的，属性名可以在运行时计算得出，可以使用变量、字符串字面量或表达式。可以使用数字作为属性名。

## 什么是变量提升?根据变量提升的规则，写出代码执行结果。

```js
var a = 1;

function foo() {
    console.log("我是第一个a", a) // undefined
    var a = 3
    console.log("我是第二个a", a) // 3
}

console.log("我是第三个a", a) // 1

foo()
```

## 对作用域链和立即执行函数了解多少?判断以下函数的输出。

```js
var test = "hello";
(function test() {
    //在函数内部引用test时，会查找最近的作用域里的test变量或函数，而不会查找外部作用域的，在这种情况下，函数test遮蔽了外部的test变量
    test = "小诺"//函数的名称是只读的，所以不能在函数内部修改函数的名称，因此此行代码无效
    console.log(test) //test函数
})()
```

## 如何判断回调函数中this的指向？这段代码最终输出多少？

```js
var name = "小诺"
let obj = {
    name: "小诺2号",
    //根据调用时的上下文来判定
    say: function () {
        console.log(this.name)
    },
    //根据定义时的上下文来判断
    arrowSay: () => {
        console.log(this.name)
    }
}
obj.say() //小诺2号
obj.arrowSay() //小诺
//当say函数作为setTimeout的回调函数时，它失去了原本的上下文环境。在非箭头函数中，
// this的值通常在函数被调用时确定，因此在这种情况下，this默认指向全局对象（浏览器中是window），所以它打印的是全局变量name的值"小诺"
setTimeout(obj.say, 1000) //小诺
//当箭头函数arrowSay被传递给setTimeout时，虽然执行环境发生了变化，但是箭头函数内部的this绑定不会改变，
// 它依然引用的是定义时的上下文，即全局对象。因此，它打印的是全局变量name的值"小诺"
setTimeout(obj.arrowSay, 2000) //小诺
```

## 社么是柯里化？如何实现一个柯里化函数？

柯里化（Currying）是一种将多参数函数转换为一系列单参数函数的技术。简单来说，就是将一个接受多个参数的函数转换为接受第一个参数后返回一个新的函数，
这个新函数再接受下一个参数，以此类推，直到所有的参数都被传递完毕，最后执行真正的计算并返回结果。这一过程可以看作是把一个多参数的函数“分步骤”执行。

### 为什么使用柯里化？

- 提前部分应用: 可以提前固定部分参数，创建特定场景下的新函数。
- 易于函数组合: 柯里化的函数天然适合函数组合，有助于编写更加模块化和可重用的代码。
- 减少代码重复: 对于有共同参数的函数调用，可以通过柯里化避免重复传入相同的参数。

### 实现一个简单的柯里化函数

```js
function curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            // 当收集到的参数数量达到原函数所需参数数量时，执行原函数
            return func.apply(this, args);
        } else {
            // 否则，返回一个新的函数继续收集参数
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

// 使用柯里化函数
function sum(a, b, c) {
    return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)); // 输出: 6
console.log(curriedSum(1, 2)(3)); // 输出: 6
console.log(curriedSum(1)(2, 3)); // 输出: 6
```

在这个例子中，curry函数接收一个多参数的函数func作为参数，然后返回一个新的函数curried。curried函数会检查当前收集到的参数数量是否已经满足func的要求，
如果满足就直接执行func，否则继续返回一个新的函数来收集更多的参数。这样，我们就可以根据需要逐步传递参数，实现函数的柯里化。

## 什么是属性描述符？请用属性描述符改写test构造函数。

### 定义

在JavaScript中，属性描述符（Property
Descriptors）是一种内部特性，它用于详细定义一个对象属性的行为。每个属性都有一个与之关联的属性描述符，这个描述符是一个对象，包含了多个属性来描述该属性的特征，如是否可枚举（enumerable）、是否可配置（configurable）、是否可写（writable），以及对于访问器属性（accessor
properties）的getter和setter函数。

属性描述符主要分为两种类型：

- **数据描述符（Data Descriptors）**:
  包含value（属性的值）、writable（是否可写）、enumerable（是否可枚举）和configurable（是否可配置）四个属性。如果描述符中包含value或writable，则该描述符为数据描述符。
- **存取器描述符（Accessor Descriptors）**:
  包含get（获取属性值的函数）和set（设置属性值的函数）两个属性，以及可选的enumerable和configurable。如果描述符中包含get或set，则该描述符为存取器描述符。注意，存取器描述符没有value或writable属性。

### 优势

- **灵活性和控制力**: 属性描述符提供了对对象属性的高级控制，使开发者能够根据需要调整属性的访问和修改规则，增强代码的灵活性和安全性。

- **动态性**:
  可以在运行时通过Object.getOwnPropertyDescriptor获取属性描述符，或使用Object.defineProperty和Object.defineProperties来修改已有属性或添加新属性及其描述符，使得对象的结构和行为能在程序运行过程中动态调整。

- **封装和抽象**: 利用存取器描述符，可以实现属性的读写逻辑封装，比如验证赋值、触发副作用、实现懒加载等，从而提高代码的封装性和抽象层次。

- **元编程能力**: 属性描述符是JavaScript元编程的一个重要方面，它允许程序员在运行时操作和修改对象的底层结构，为创建框架、库或高级抽象提供了强大的工具。

- **响应式编程**: 在一些前端框架（如Vue.js）中，属性描述符被用来实现数据的响应式更新，当属性值发生变化时自动触发视图的更新，这是现代前端开发中的一个重要特性。

### 题目解析

```js
function Test(a, b, c) {
    this.a = a
    this.b = b
    this.c = c
    Object.defineProperty(this, "sum", {
        get: function () {
            return this.a + this.b + this.c
        }
    })
}

let obj = new Test(1, 2, 3)
//访问obj.sum时其只作为一个只读属性存在，并且在a、b、c的值修改后都可以实时响应更新。
console.log(obj)
```

## 如何判定函数的length属性？

在JavaScript中，函数的length属性是用来获取函数定义时形式参数（形参）的数量，即函数签名中列出的参数个数，而不考虑实际调用时传递了多少个参数或是参数是否有默认值。判断一个函数的length属性遵循以下规则：

1. **仅计算非默认值参数**：如果函数定义中包含带有默认值的参数，并且这些参数位于没有默认值的参数之后，那么length属性将不包括这些带默认值的参数。例如，在function f(a, b = 2, c)
   {}中，f.length将是2，因为c之后的带有默认值的参数b不计入length。

2. **忽略剩余参数**：即使函数定义中包含剩余参数（如...args），这些也不会计入length的计算中。

3. **基于函数定义而非调用**：函数的length属性是基于函数定义时的形式参数数量，而不是函数实际被调用时传递的实参数量。

4. **始终为非负整数**：函数的length属性总是返回一个非负整数，表示形式参数的数量。如果没有参数，则length为0。

```js
function example(a, b, c) {
} // length = 3
function exampleWithDefault1(a, b = 1) {
} // length = 1，因为b有默认值，但a没有
function exampleWithDefault2(a = 1, b) {
} // length = 0，因为a有默认值且为第一个参数
function exampleWithRest(...args) {
} // length = 0，因为只有rest参数
function combinedExample(a, b = 2, ...args) {
} // length = 1，a是唯一没有默认值的参数


console.log(example.length); // 输出：3
console.log(exampleWithDefault1.length); // 输出：1
console.log(exampleWithDefault2.length); // 输出：0
console.log(exampleWithRest.length); // 输出：0
console.log(combinedExample.length); // 输出：1
```

## 讲一下函数的剩余参数及示例。

在JavaScript中，剩余参数（Rest Parameters）是一种特殊的语法，它允许你在函数定义中捕获不确定数量的参数，并将它们作为一个数组来处理。
剩余参数以三个点（...）跟随着一个参数名称来表示。这种方式让你能够编写更加灵活的函数，特别是在处理可变数量的输入时非常有用。

### 基本语法

```js
function functionName(...restParameterName) {
    // 函数体
}
```

### 应用示例

::: code-group

```js [求和函数]
function sum(...numbers) {
    return numbers.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3)); // 输出：6
console.log(sum(10, 20)); // 输出：30
console.log(sum()); // 输出：0
```

```js [收集参数]
function displayInfo(name, ...otherInfo) {
    console.log(`Name: ${name}`);
    console.log("Other Info:", otherInfo);
}

displayInfo("Alice", "Age: 30", "Occupation: Developer");
// 输出：
// Name: Alice
// Other Info: ["Age: 30", "Occupation: Developer"]
```

```js [结合结构]
function handleArray(first, second, ...rest) {
    console.log('First:', first);
    console.log('Second:', second);
    console.log('Rest:', rest);
}

let array = [1, 2, 3, 4, 5];
handleArray(...array); // 结果是通过解构数组传递参数
// 输出：
// First: 1
// Second: 2
// Rest: [3, 4, 5]
```

:::

### 注意事项

- 剩余参数必须是函数参数列表中的最后一个参数。
- 它们总是被收集为一个数组，即使只有一个参数也会被包装成数组。
- 剩余参数与arguments对象不同，arguments是一个类数组对象，包含了函数调用时传入的所有参数，而剩余参数则是一个真正的数组，支持所有数组的方法。

## 说明一下箭头函数和传统函数的this指向问题。

在JavaScript中，this关键字的指向是许多开发者初学时容易混淆的概念，特别是当涉及到普通函数（也称为传统函数）与箭头函数时。下面将分别介绍两者中this的指向规则及差异。

### 传统函数

传统函数的`this`关键字的值在运行时决定，具体取决于函数调用的上下文，这可能导致非直观的行为：

1. **作为对象方法调用**：如果函数是某个对象的属性（即方法），this指向该对象。

```js
const person = {
    name: 'Alice',
    sayHello: function () {
        console.log(this.name);
    }
};
person.sayHello(); // 输出 'Alice'，因为this指向person对象
```

2. **全局上下文或严格模式下**：在全局作用域中调用函数，或者在严格模式下，this通常指向undefined（严格模式下）或全局对象（非严格模式下，浏览器环境中的window对象）。

```js
function globalFunc() {
    console.log(this);
}

globalFunc(); // 非严格模式下输出 window，严格模式下输出 undefined
```

3. **构造函数**：如果函数通过new关键字调用，this指向新创建的对象实例。

```js
function Person(name) {
    this.name = name;
}

const alice = new Person('Alice');
console.log(alice.name); // 输出 'Alice'
```

### 箭头函数

箭头函数在设计上简化了this的规则，它不绑定自己的this值，而是继承自外层（即包含箭头函数的上下文）的this值。这意味着箭头函数内的this是在定义函数的那个时刻被确定的，而不是在调用时。

```js
const person = {
    name: 'Alice',
    sayHello: () => {
        console.log(this.name);
    }
};
person.sayHello(); // 输出可能不是预期的 'Alice'，因为箭头函数的this继承自外层作用域
```

在上述例子中，如果sayHello是箭头函数，它的this不会自动指向person对象，而是指向定义箭头函数时所在的作用域的this。如果是在全局作用域定义，
this可能指向window（浏览器环境）或global（Node.js环境），或者如果是严格模式下，则为undefined。

### 总结

- **传统函数**：this的值在调用时确定，依赖于函数的调用方式（直接调用、作为对象方法、构造函数调用等）。
- **箭头函数**：this由定义时所在的上下文决定，不随调用方式改变，通常指向外层非箭头函数的this。

因此，当你需要在函数内部维持一个固定的this引用，特别是在处理异步操作或回调函数时，箭头函数是一个很好的选择。而在需要动态或特定上下文的this时，则应使用传统函数并考虑使用.bind()、.call()或.apply()
方法来明确指定this。