# 面试题合集

## 如何判断函数的this?请说出这2个函数的执行结果

```javascript
var length = 1

function fun() {
    console.log(this.length)
}

let arr = [fun, "a", "b"]
arr[0]() //输出什么?
let fun2 = arr[0]
fun2() //输出什么?
```

此时的`arr[0]`是fun的引用。当执行`arr[0]()`时，实际上是在arr的上下文中调用fun函 数。因为我们从数组arr中取出了一个函数，并且立即调用。
所以，此时this指向数组arr。因此第一个打印显示3，第二个等同于window.fun2()，所以第二个打印1。

## 什么是惰性函数?如何实现惰性函数?

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        element.addEventListener(type, handler, false) //Chrome和Edge
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler) //IE8 之前的旧浏览器
    } else {
        element["on" + type] = handler // 所有老版本的浏览器
    }
}
```

惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。
惰性函数的本质就是`函数重写`，所谓惰性载入，指函数执行的分支只会发生一次，正确答案如下，首次执行原有逻辑不变的同时，对原函数进行修改，下次就会跳过判断直接执行。

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        //首次执行逻辑保持不变
        element.addEventListener(type, handler, false)
        //检测到Chrome和Edge后改写
        addEvent = function (element, type, handler) {
            element.addEventListener(type, handler, false)
        }
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler)
        //检测到 IE8 之前的旧浏览器
        addEvent = function (element, type, handler) {
            element.attachEvent("on" + type, handler)
        }
    } else {
        element["on" + type] = handler
        // 检测到所有老版本的浏览器
        addEvent = function (element, type, handler) {
            element["on" + type] = handler
        }
    }
}
```

## forEach函数的原理是什么?为什么不会无限循环?

```javascript
let numbersOne = [1, 2, 3]
numbersOne.forEach((number, index) => {
    console.log(number)
    numbersOne.push("小诺")
})
console.log("会有多少小诺呢", numbersOne)
```

根据ecma规范手动实现forEach函数

```javascript
Array.prototype.xnForEach = function (callback, arg) {
    if (this === null || this === undefined) {
        throw new TypeError("this不能是null或者undefined")
    }
    let o = this
    let len = o.length
    if (typeof callback !== "function") {
        throw new TypeError("callback不是函数")
    }
    for (let k = 0; k < len; k++) {
        if (k in o) {
            let keyValue = o[k]
            callback.call(args, keyValue, k, o)
        }
    }
    return undefined
}
```

## 如何实现一个完整的发布订阅模式?

### 定义

发布订阅模式是一种常见的设计模式，在许多场景中都有应用。我们可能已经在使用中接触过发布订阅模式，比如使用 addEventListener 方法来监听 DOM 事件、Vue 的事件总线机制等。

### 实际案例

- 在 JavaScript 中，我们可以使用 DOM 2 级事件的 addEventListener 方法来订阅和监听事件。
- 在 Electron 中，使用 IpcMain 和 ipcRender 来实现主进程和渲染进程之间的事件通信。
- 在 Webpack 中，使用 Hooks 机制来订阅和处理构建过程中的各个阶段。
- 在 Vue 2 中，可以使用事件总线（Event Bus）机制来实现组件之间的通信。

### 示例代码

```typescript
interface EventFace {
    //订阅/监听
    on: (name: string, callback: Function) => void
    //发布/注册
    emit: (name: string, ...args: Array<any>) => void
    //解除绑定
    off: (name: string, fn: Function) => void
    //只执行一次
    once: (name: string, fn: Function) => void
}

interface List {
    [key: string]: Array<Function>
}

class Dispatch implements EventFace {
    list: List

    constructor() {
        this.list = {}
    }

    // 订阅事件
    on(name: string, callback: Function) {
        const callbackList: Array<Function> = this.list[name] || []
        callbackList.push(callback)
        this.list[name] = callbackList
    }

    // 发布事件
    emit(name: string, ...args: Array<any>) {
        let eventName = this.list[name]
        if (eventName) {
            eventName.forEach(fn => {
                fn.apply(this, args)
            })
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 解除绑定
    off(name: string, fn: Function) {
        let eventName = this.list[name]
        if (eventName && fn) {
            let index = eventName.findIndex(fnItem => fnItem === fn)
            eventName.splice(index, 1)
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 一次性订阅
    once(name: string, fn: Function) {
        let decorator = (...args: Array<any>) => {
            fn.apply(this, args)
            this.off(name, decorator)
        }
        this.on(name, decorator)
    }
}

const o = new Dispatch()

// 订阅事件 'abc'，输出参数
o.on('abc', (...arg: Array<any>) => {
    console.log(arg)
})

// 一次性订阅事件 'abc'，输出参数和字符串 'once'，只会触发一次
o.once('abc', (...arg: Array<any>) => {
    console.log(arg, 'once')
})

// 发布事件 'abc'，输出参数 1、小诺、小诺
o.emit('abc', 1, "小诺", "小诺")

// 再次发布事件 'abc'，输出参数  2、小诺、小诺
o.emit('abc', 2, "小诺", "小诺")
```

## ["1","2","3"].map(parseInt)的输出结果是多少?parseInt第二个参数的作用是什么?

```javascript
console.log(["1", "2", "3"].map(parseInt))
```

parseInt方法接收两个参数，第一个参数为要被解析的字符串，而已知map会传递的参数是(item,index,arr)这种结构，
因此parseInt会接收到三组数据"1" 0, "2" 1 , "3":2,parseInt第二个参数是解析数字的基数，如果不传或传0则默认
为10进制，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN，因此第二组数据返回NaN,第三组数据指定为2进制
但第一个参数确是3，不满足二进制只有0、1的条件，因此也返回NaN，所有`正确答案是[1、NaN、NaN]`

## Object.is和===有哪些区别?他们各自的判断规则是什么?

```javascript
let obj1 = {}
let obj2 = {}
console.log(obj1 == obj2) //false
console.log(obj1 === obj2) //false
console.log(Object.is(obj1, obj2)) //false
```

### 非严格相等的隐式类型转化规则

```javascript
//特殊情况1
console.log(null == undefined) //true
//特性情况2
console.log(NaN == "xiaonuo") // false
console.log(NaN == NaN) // false
```

相等比较(==)

1.如果两个操作数类型相同，执行严格比较。

2.如果两个操作数类型不同，则进行**类型转换**后再进行比较，规则如下：

- 如果一个操作数是数值(number),另一个操作数是字符串，则将**字符串转换为数值**，然后进行比较。
- 如果一个操作数是布尔值，则将**布尔值转换为数值**，然后进行比较。
- 如果一个操作数是对象，另一个操作数是数值或字符串，则将**对象转换为原始值**，然后比较。

关于将对象转换为原始值，如果一个操作数是对象，另一个操作数是字符串或者数字，会首先调用对象的valueOf()方法，将对象转化为基本类型，再进行比较，当valueOf()返回的不是基本类型的
时候，才会调用toString()方法，示例如下。

```javascript
let obj1 = {
    valueOf() {
        return 1
    },
    toString() {
        return "2"
    }
}

console.log(obj1 == "2") //false
console.log(obj1 == 1) // true

let obj2 = {
    valueOf() {
        return {}
    },
    toString() {
        return "2"
    }
}

console.log(obj2 == "2") //true
console.log(obj2 == 1) // false

```

### Object.is 和 === 的规则

Object.is 和 === 再比较两个值时**都不会进行类型转换**

Object.is :

- 当比较NaN时，Object.is(NaN,NaN)返回true
- 当比较+0和-0时，Object.is(+0,-0)返回false,它能区分正零和负零(如果要区分正负应使用Object.is)

=== :

- NaN === NaN返回false,因为NaN是不等于任何值，包括它自己
- 对于+0和-0，+0 === -0返回true，因为**严格相等不区分正负**

## 连续赋值的计算规则是什么?这段代码的输出结果是什么

赋值的返回结果就是你赋的值

```javascript
var obj1 = {age: 18}
var obj2 = obj1
obj1.prop = obj1 = {age: 19}
console.log(obj1)//{age:19}
console.log(obj2)//{age:18,prop:{age:19}}
``` 

## 如何实现数组索引的累加?考察对Proxy对象的理解

```javascript
const obj = {sum: 0}
const add = new Proxy(obj, {
    get: function (target, prop, receiver) {
        // 如果add对象和数字相加，则把目标对象的obj的sum和数字相加
        // 如果访问add对象的索引，则把当前索引累积到sum中
        if (prop === Symbol.toPrimitive) {
            const ret = target.sum
            target.sum = 0
            return () => ret
        } else {
            const sum = (target.sum || 0) + Number(prop)
            target.sum = sum
            return receiver
        }
    }
})
//当一个对象和数字相加时，他会调用对象的toPrimitive方法，尝试将对象转化成原始类型再来相加
const result1 = add[1][2] + 3 //6
const result2 = add[3][4][5] + 6 //18

console.log(result1, result2)
```

## 求最长递增子序列(LIS)

```javascript
 function LTS(nums) {
    if (nums.length === 0) return []
    const result = [[nums[0]]]
    for (let i = 0; i < nums.length; i++) {
        const n = nums[i]
        update(n)
    }

    function update(n) {
        for (let i = result.length - 1; i >= 0; i--) {
            const line = result[i]
            const tail = line[line.length - 1]
            if (n > tail) {
                result[i + 1] = [...line, n]
                break;
            } else if (n < tail && i === 0) {
                result[i] = [n]
            }
        }
    }

    return result[result.length - 1]
}

console.log(LTS([4, 5, 1, 2, 7, 3, 6, 9]))
```

## var、let、const之间有哪些区别?你能否回答完整?

```javascript
var a = "小诺"
let b = "小诺"
const c = "小诺"
```

### 作用域不同

var声明的变量，其作用域是**全局作用域或函数作用域**，let和const是**块作用域**,块是由{}包裹起来的代码，换句话说**被一对花括号包起来的代码都属于一个块**。

::: code-group

```js [var]
var a = "小诺"
console.log(a) // 小诺

function newFunc() {
    var b = "小诺"
}

console.log(b) // b is not defined
```

```js [let、const]
let times = 4
if (times > 3) {
    var b = "小诺"
    let c = "小诺"
    console.log(b)//小诺
    console.log(c)//小诺
}
console.log(b) // 小诺
console.log(c) // c is not define
```

:::

### 声明及定义

- var变量可以更新和重新声明
- let变量可以更新不能重新声明
- const变量不能更新也不能重新声明

::: code-group

```js [var]
var x = 1
var x = 2
console.log(x) // 2
```

```js [let]
let x = 1
x = 2
console.log(x) // 2
let x = 3 //报错，变量x已经被定义
```

```js [const]
const x = 1
x = 2 //提示该变量是const变量无法修改
const x = 2 //报错，变量x已经被定义
```

:::

### 变量提升

在代码执行之前，将变量声明和函数声明提升到当前作用域的顶部，需要注意的是，只有声明会被提升，赋值操作不会被提升,而在变量提升方面，他们都被提升到了
作用域的顶部。但是var变量会被初始化为undefined，let、const不会被初始化。

::: code-group

```js [var]
console.log(x) //undefined
var x = "小诺"
console.log(x) //小诺
```

```js [let]
console.log(x) //报错，不能访问x在初始化之前
let x = "小诺"
console.log(x) //小诺
```

```js [const]
console.log(x) //报错，不能访问x在初始化之前
const x = "小诺"
console.log(x) //小诺
```

:::

## 如何访问对象的属性?点符号访问和方括号访问的区别是什么?

(.)操作符访问的是静态属性，属性名是硬编码，且在编写代码时就已知，不能使用变量作为属性名，也不能用数字作为属性名，这是因为**点表示法
要求属性名必须是一个有效的JavaScript标识符**。

方括号访问的属性是动态的，属性名可以在运行时计算得出，可以使用变量、字符串字面量或表达式。可以使用数字作为属性名。

## 什么是变量提升?根据变量提升的规则，写出代码执行结果。

```js
var a = 1;

function foo() {
    console.log("我是第一个a", a) // undefined
    var a = 3
    console.log("我是第二个a", a) // 3
}

console.log("我是第三个a", a) // 1

foo()
```

## 对作用域链和立即执行函数了解多少?判断以下函数的输出。

```js
var test = "hello";
(function test() {
    //在函数内部引用test时，会查找最近的作用域里的test变量或函数，而不会查找外部作用域的，在这种情况下，函数test遮蔽了外部的test变量
    test = "小诺"//函数的名称是只读的，所以不能在函数内部修改函数的名称，因此此行代码无效
    console.log(test) //test函数
})()
```

## 如何判断回调函数中this的指向？这段代码最终输出多少？

```js
var name = "小诺"
let obj = {
    name: "小诺2号",
    //根据调用时的上下文来判定
    say: function () {
        console.log(this.name)
    },
    //根据定义时的上下文来判断
    arrowSay: () => {
        console.log(this.name)
    }
}
obj.say() //小诺2号
obj.arrowSay() //小诺
//当say函数作为setTimeout的回调函数时，它失去了原本的上下文环境。在非箭头函数中，
// this的值通常在函数被调用时确定，因此在这种情况下，this默认指向全局对象（浏览器中是window），所以它打印的是全局变量name的值"小诺"
setTimeout(obj.say, 1000) //小诺
//当箭头函数arrowSay被传递给setTimeout时，虽然执行环境发生了变化，但是箭头函数内部的this绑定不会改变，
// 它依然引用的是定义时的上下文，即全局对象。因此，它打印的是全局变量name的值"小诺"
setTimeout(obj.arrowSay, 2000) //小诺
```

## 什么是柯里化？如何实现一个柯里化函数？

柯里化（Currying）是一种将多参数函数转换为一系列单参数函数的技术。简单来说，就是将一个接受多个参数的函数转换为接受第一个参数后返回一个新的函数，
这个新函数再接受下一个参数，以此类推，直到所有的参数都被传递完毕，最后执行真正的计算并返回结果。这一过程可以看作是把一个多参数的函数“分步骤”执行。

### 为什么使用柯里化？

- 提前部分应用: 可以提前固定部分参数，创建特定场景下的新函数。
- 易于函数组合: 柯里化的函数天然适合函数组合，有助于编写更加模块化和可重用的代码。
- 减少代码重复: 对于有共同参数的函数调用，可以通过柯里化避免重复传入相同的参数。

### 实现一个简单的柯里化函数

```js
function curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            // 当收集到的参数数量达到原函数所需参数数量时，执行原函数
            return func.apply(this, args);
        } else {
            // 否则，返回一个新的函数继续收集参数
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

// 使用柯里化函数
function sum(a, b, c) {
    return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)); // 输出: 6
console.log(curriedSum(1, 2)(3)); // 输出: 6
console.log(curriedSum(1)(2, 3)); // 输出: 6
```

在这个例子中，curry函数接收一个多参数的函数func作为参数，然后返回一个新的函数curried。curried函数会检查当前收集到的参数数量是否已经满足func的要求，
如果满足就直接执行func，否则继续返回一个新的函数来收集更多的参数。这样，我们就可以根据需要逐步传递参数，实现函数的柯里化。

## 什么是属性描述符？请用属性描述符改写test构造函数。

### 定义

在JavaScript中，属性描述符（Property
Descriptors）是一种内部特性，它用于详细定义一个对象属性的行为。每个属性都有一个与之关联的属性描述符，这个描述符是一个对象，包含了多个属性来描述该属性的特征，如是否可枚举（enumerable）、是否可配置（configurable）、是否可写（writable），以及对于访问器属性（accessor
properties）的getter和setter函数。

属性描述符主要分为两种类型：

- **数据描述符（Data Descriptors）**:
  包含value（属性的值）、writable（是否可写）、enumerable（是否可枚举）和configurable（是否可配置）四个属性。如果描述符中包含value或writable，则该描述符为数据描述符。
- **存取器描述符（Accessor Descriptors）**:
  包含get（获取属性值的函数）和set（设置属性值的函数）两个属性，以及可选的enumerable和configurable。如果描述符中包含get或set，则该描述符为存取器描述符。注意，存取器描述符没有value或writable属性。

### 优势

- **灵活性和控制力**: 属性描述符提供了对对象属性的高级控制，使开发者能够根据需要调整属性的访问和修改规则，增强代码的灵活性和安全性。

- **动态性**:
  可以在运行时通过Object.getOwnPropertyDescriptor获取属性描述符，或使用Object.defineProperty和Object.defineProperties来修改已有属性或添加新属性及其描述符，使得对象的结构和行为能在程序运行过程中动态调整。

- **封装和抽象**: 利用存取器描述符，可以实现属性的读写逻辑封装，比如验证赋值、触发副作用、实现懒加载等，从而提高代码的封装性和抽象层次。

- **元编程能力**: 属性描述符是JavaScript元编程的一个重要方面，它允许程序员在运行时操作和修改对象的底层结构，为创建框架、库或高级抽象提供了强大的工具。

- **响应式编程**: 在一些前端框架（如Vue.js）中，属性描述符被用来实现数据的响应式更新，当属性值发生变化时自动触发视图的更新，这是现代前端开发中的一个重要特性。

### 题目解析

```js
function Test(a, b, c) {
    this.a = a
    this.b = b
    this.c = c
    Object.defineProperty(this, "sum", {
        get: function () {
            return this.a + this.b + this.c
        }
    })
}

let obj = new Test(1, 2, 3)
//访问obj.sum时其只作为一个只读属性存在，并且在a、b、c的值修改后都可以实时响应更新。
console.log(obj)
```

## 如何判定函数的length属性？

在JavaScript中，函数的length属性是用来获取函数定义时形式参数（形参）的数量，即函数签名中列出的参数个数，而不考虑实际调用时传递了多少个参数或是参数是否有默认值。判断一个函数的length属性遵循以下规则：

1. **仅计算非默认值参数**：如果函数定义中包含带有默认值的参数，并且这些参数位于没有默认值的参数之后，那么length属性将不包括这些带默认值的参数。例如，在function f(a, b = 2, c)
   {}中，f.length将是2，因为c之后的带有默认值的参数b不计入length。

2. **忽略剩余参数**：即使函数定义中包含剩余参数（如...args），这些也不会计入length的计算中。

3. **基于函数定义而非调用**：函数的length属性是基于函数定义时的形式参数数量，而不是函数实际被调用时传递的实参数量。

4. **始终为非负整数**：函数的length属性总是返回一个非负整数，表示形式参数的数量。如果没有参数，则length为0。

```js
function example(a, b, c) {
} // length = 3
function exampleWithDefault1(a, b = 1) {
} // length = 1，因为b有默认值，但a没有
function exampleWithDefault2(a = 1, b) {
} // length = 0，因为a有默认值且为第一个参数
function exampleWithRest(...args) {
} // length = 0，因为只有rest参数
function combinedExample(a, b = 2, ...args) {
} // length = 1，a是唯一没有默认值的参数


console.log(example.length); // 输出：3
console.log(exampleWithDefault1.length); // 输出：1
console.log(exampleWithDefault2.length); // 输出：0
console.log(exampleWithRest.length); // 输出：0
console.log(combinedExample.length); // 输出：1
```

## 讲一下函数的剩余参数及示例。

在JavaScript中，剩余参数（Rest Parameters）是一种特殊的语法，它允许你在函数定义中捕获不确定数量的参数，并将它们作为一个数组来处理。
剩余参数以三个点（...）跟随着一个参数名称来表示。这种方式让你能够编写更加灵活的函数，特别是在处理可变数量的输入时非常有用。

### 基本语法

```js
function functionName(...restParameterName) {
    // 函数体
}
```

### 应用示例

::: code-group

```js [求和函数]
function sum(...numbers) {
    return numbers.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3)); // 输出：6
console.log(sum(10, 20)); // 输出：30
console.log(sum()); // 输出：0
```

```js [收集参数]
function displayInfo(name, ...otherInfo) {
    console.log(`Name: ${name}`);
    console.log("Other Info:", otherInfo);
}

displayInfo("Alice", "Age: 30", "Occupation: Developer");
// 输出：
// Name: Alice
// Other Info: ["Age: 30", "Occupation: Developer"]
```

```js [结合结构]
function handleArray(first, second, ...rest) {
    console.log('First:', first);
    console.log('Second:', second);
    console.log('Rest:', rest);
}

let array = [1, 2, 3, 4, 5];
handleArray(...array); // 结果是通过解构数组传递参数
// 输出：
// First: 1
// Second: 2
// Rest: [3, 4, 5]
```

:::

### 注意事项

- 剩余参数必须是函数参数列表中的最后一个参数。
- 它们总是被收集为一个数组，即使只有一个参数也会被包装成数组。
- 剩余参数与arguments对象不同，arguments是一个类数组对象，包含了函数调用时传入的所有参数，而剩余参数则是一个真正的数组，支持所有数组的方法。

## 说明一下箭头函数和传统函数的this指向问题。

在JavaScript中，this关键字的指向是许多开发者初学时容易混淆的概念，特别是当涉及到普通函数（也称为传统函数）与箭头函数时。下面将分别介绍两者中this的指向规则及差异。

### 传统函数

传统函数的`this`关键字的值在运行时决定，具体取决于函数调用的上下文，这可能导致非直观的行为：

1. **作为对象方法调用**：如果函数是某个对象的属性（即方法），this指向该对象。

```js
const person = {
    name: 'Alice',
    sayHello: function () {
        console.log(this.name);
    }
};
person.sayHello(); // 输出 'Alice'，因为this指向person对象
```

2. **全局上下文或严格模式下**：在全局作用域中调用函数，或者在严格模式下，this通常指向undefined（严格模式下）或全局对象（非严格模式下，浏览器环境中的window对象）。

```js
function globalFunc() {
    console.log(this);
}

globalFunc(); // 非严格模式下输出 window，严格模式下输出 undefined
```

3. **构造函数**：如果函数通过new关键字调用，this指向新创建的对象实例。

```js
function Person(name) {
    this.name = name;
}

const alice = new Person('Alice');
console.log(alice.name); // 输出 'Alice'
```

### 箭头函数

箭头函数在设计上简化了this的规则，它不绑定自己的this值，而是继承自外层（即包含箭头函数的上下文）的this值。这意味着箭头函数内的this是在定义函数的那个时刻被确定的，而不是在调用时。

```js
const person = {
    name: 'Alice',
    sayHello: () => {
        console.log(this.name);
    }
};
person.sayHello(); // 输出可能不是预期的 'Alice'，因为箭头函数的this继承自外层作用域
```

在上述例子中，如果sayHello是箭头函数，它的this不会自动指向person对象，而是指向定义箭头函数时所在的作用域的this。如果是在全局作用域定义，
this可能指向window（浏览器环境）或global（Node.js环境），或者如果是严格模式下，则为undefined。

### 总结

- **传统函数**：this的值在调用时确定，依赖于函数的调用方式（直接调用、作为对象方法、构造函数调用等）。
- **箭头函数**：this由定义时所在的上下文决定，不随调用方式改变，通常指向外层非箭头函数的this。

因此，当你需要在函数内部维持一个固定的this引用，特别是在处理异步操作或回调函数时，箭头函数是一个很好的选择。而在需要动态或特定上下文的this时，则应使用传统函数并考虑使用.bind()、.call()或.apply()
方法来明确指定this。

## Vue3为什么使用Proxy而不使用Object.defineProperty？

1. **全面性：** Proxy可以拦截对象上几乎所有的操作，包括但不限于读取、设置属性值，还包括了数组索引的修改、新增属性、删除属性等。这使得Vue 3能够更自然地追踪数据变化，而无需特别处理数组或新属性的响应式问题。
2. **动态响应：** Object.defineProperty只能对已有属性进行响应式处理，对于动态添加的属性则需要额外的逻辑（如Vue
   2中的Vue.set）。而Proxy能够自动追踪并响应对象结构的变化，包括新属性的添加和已有属性的删除。
3. **性能优化：**
   尽管在某些场景下直接比较可能各有胜负，但总体而言，Proxy的实现避免了Object.defineProperty所需的深度遍历，特别是在处理深层嵌套或大型对象时，性能表现更佳。Proxy的拦截机制在设计上更利于现代JavaScript引擎的优化。
4. **代码简洁性：** 使用Proxy可以简化响应式系统的实现代码，减少了许多针对特定情况的特殊处理逻辑，使得代码更易于维护和理解。
5. **未来导向：** Proxy是ES6引入的新特性，代表着JavaScript语言的进化方向。Vue 3作为新一代框架，采用Proxy有助于保持技术栈的现代性，同时确保与未来浏览器和JavaScript特性的良好兼容性。

## 在浏览器中输入链接按下回车到网页显示发生了什么？

1. **解析URL**：浏览器首先解析你输入的URL，确定要访问的服务器地址、路径、协议类型等信息。

2. **DNS查询**：浏览器通过DNS（域名系统）将网站的域名转换为IP地址。这个过程可能涉及本地缓存、路由器缓存、ISP DNS服务器乃至根域名服务器的查询。

3. **建立TCP连接**：获取到IP地址后，浏览器使用TCP协议与服务器建立连接。这通常涉及三次握手过程，确保双方都能发送和接收数据。

4. **发送HTTP/HTTPS请求**
   ：建立连接后，浏览器构造一个HTTP或HTTPS请求报文，包括请求行（方法、URL、协议版本）、请求头（如User-Agent、Accept-Language）以及可能的请求体（POST请求时），然后发送给服务器。

5. **服务器处理请求**：服务器接收到请求后，根据请求内容进行处理。这可能包括执行服务器端脚本（如PHP、Node.js）、查询数据库、生成动态内容等。

6. **服务器返回响应**：服务器完成处理后，构造一个HTTP响应报文，包括状态码（如200 OK表示成功）、响应头（如Content-Type指示内容类型）以及响应体（即实际的网页内容），并通过TCP连接发送给浏览器。

7. **下载资源**
   ：浏览器接收到HTML响应后，开始解析HTML文档，构建DOM树。在解析过程中，遇到CSS、JavaScript文件、图片等外部资源时，浏览器会根据需要发送额外的请求去获取这些资源。这一步也可能涉及DNS查询、TCP连接和HTTP请求。

8. **渲染页面**：

- 构建CSSOM：浏览器解析CSS文件，构建CSSOM（CSS对象模型）。
- 渲染树构建：结合DOM树和CSSOM，构建渲染树，该树只包含需要渲染的元素及其样式。
- 布局：根据渲染树计算每个节点的几何位置，即布局或回流过程。
- 绘制：遍历渲染树并使用UI后端层将节点绘制到屏幕上。

9. **执行JavaScript**：在页面加载过程中或页面加载完成后，浏览器会解析并执行JavaScript代码。这可能会影响DOM结构、CSSOM或触发额外的网络请求，导致重新布局或绘制。

10. **交互与后续请求**：页面完全加载后，用户可以与页面交互。交互过程中，可能触发额外的AJAX请求、WebSocket通信等，进一步更新页面内容。

## 介绍一下纯函数和非纯函数

纯函数（Pure
Function）是指那些对于相同的输入，总是产生相同输出，并且在执行过程中不产生任何可观察的副作用（例如修改外部状态、修改输入参数、进行IO操作等）的函数。它们遵循函数式编程的原则，使得程序更容易理解和预测，同时也便于测试和并行处理。下面通过几个例子来具体说明：

### 纯函数示例

1. 基本数学运算

```javascript
function add(a, b) {
    return a + b;
}
```

这个add函数接受两个参数a和b，返回它们的和。无论何时调用add(2, 3)，结果总是5，不会受外部条件影响，也不改变输入参数或外部状态。

2. 字符串操作

```javascript
  function concatenate(str1, str2) {
    return str1 + str2;
}
```

concatenate函数将两个字符串连接起来。例如，concatenate("Hello, ", "world!")始终返回"Hello, world!"，不依赖于外部状态，也没有副作用。

3. 数组操作：slice

```javascript
 const arr = [1, 2, 3, 4, 5];
const subArray = arr.slice(1, 3);
```

虽然这不是直接的函数调用示例，但Array.prototype.slice方法是纯函数的一个很好体现。它从原数组中返回一个新的子数组，而不改变原数组。因此，多次调用slice总是基于相同的输入产生相同的结果，不产生副作用。

### 非纯函数示例

对比之下，非纯函数可能改变外部状态或依赖外部状态，例如：

```javascript
let counter = 0;

function increment() {
    return ++counter; // 改变了外部变量counter
}

function getRandom() {
    return Math.random(); // 结果依赖于时间，每次调用可能不同
}
```

在increment函数中，因为改变了外部的counter变量，所以它不是一个纯函数。而在getRandom函数中，因为结果依赖于当前时间（尽管时间也是输入的一种形式，但这里的“输入”是隐式的，不符合纯函数定义中的显式输入参数原则），所以它也不是纯函数。