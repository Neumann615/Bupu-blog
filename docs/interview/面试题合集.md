# 面试题合集

## 如何判断函数的this?请说出这2个函数的执行结果

```javascript
var length = 1

function fun() {
    console.log(this.length)
}

let arr = [fun, "a", "b"]
arr[0]() //输出什么?
let fun2 = arr[0]
fun2() //输出什么?
```

此时的`arr[0]`是fun的引用。当执行`arr[0]()`时，实际上是在arr的上下文中调用fun函 数。因为我们从数组arr中取出了一个函数，并且立即调用。
所以，此时this指向数组arr。因此第一个打印显示3，第二个等同于window.fun2()，所以第二个打印1。

## 什么是惰性函数?如何实现惰性函数?

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        element.addEventListener(type, handler, false) //Chrome和Edge
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler) //IE8 之前的旧浏览器
    } else {
        element["on" + type] = handler // 所有老版本的浏览器
    }
}
```

惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。
惰性函数的本质就是`函数重写`，所谓惰性载入，指函数执行的分支只会发生一次，正确答案如下，首次执行原有逻辑不变的同时，对原函数进行修改，下次就会跳过判断直接执行。

```javascript
function addEvent(element, type, handler) {
    if (window.addEventListener) {
        //首次执行逻辑保持不变
        element.addEventListener(type, handler, false)
        //检测到Chrome和Edge后改写
        addEvent = function (element, type, handler) {
            element.addEventListener(type, handler, false)
        }
    } else if (window.attachEvent) {
        element.attachEvent("on" + type, handler)
        //检测到 IE8 之前的旧浏览器
        addEvent = function (element, type, handler) {
            element.attachEvent("on" + type, handler)
        }
    } else {
        element["on" + type] = handler
        // 检测到所有老版本的浏览器
        addEvent = function (element, type, handler) {
            element["on" + type] = handler
        }
    }
}
```

## forEach函数的原理是什么?为什么不会无限循环?

```javascript
let numbersOne = [1, 2, 3]
numbersOne.forEach((number, index) => {
    console.log(number)
    numbersOne.push("小诺")
})
console.log("会有多少小诺呢", numbersOne)
```

根据ecma规范手动实现forEach函数

```javascript
Array.prototype.xnForEach = function (callback, arg) {
    if (this === null || this === undefined) {
        throw new TypeError("this不能是null或者undefined")
    }
    let o = this
    let len = o.length
    if (typeof callback !== "function") {
        throw new TypeError("callback不是函数")
    }
    for (let k = 0 k < len
    k++
)
    {
        if (k in o) {
            let keyValue = o[k]
            callback.call(args, keyValue, k, o)
        }
    }
    return undefined
}
```

## 如何实现一个完整的发布订阅模式?

### 定义

发布订阅模式是一种常见的设计模式，在许多场景中都有应用。我们可能已经在使用中接触过发布订阅模式，比如使用 addEventListener 方法来监听 DOM 事件、Vue 的事件总线机制等。

### 实际案例

- 在 JavaScript 中，我们可以使用 DOM 2 级事件的 addEventListener 方法来订阅和监听事件。
- 在 Electron 中，使用 IpcMain 和 ipcRender 来实现主进程和渲染进程之间的事件通信。
- 在 Webpack 中，使用 Hooks 机制来订阅和处理构建过程中的各个阶段。
- 在 Vue 2 中，可以使用事件总线（Event Bus）机制来实现组件之间的通信。

### 示例代码

```typescript
interface EventFace {
    //订阅/监听
    on: (name: string, callback: Function) => void
    //发布/注册
    emit: (name: string, ...args: Array<any>) => void
    //解除绑定
    off: (name: string, fn: Function) => void
    //只执行一次
    once: (name: string, fn: Function) => void
}

interface List {
    [key: string]: Array<Function>
}

class Dispatch implements EventFace {
    list: List

    constructor() {
        this.list = {}
    }

    // 订阅事件
    on(name: string, callback: Function) {
        const callbackList: Array<Function> = this.list[name] || []
        callbackList.push(callback)
        this.list[name] = callbackList
    }

    // 发布事件
    emit(name: string, ...args: Array<any>) {
        let eventName = this.list[name]
        if (eventName) {
            eventName.forEach(fn => {
                fn.apply(this, args)
            })
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 解除绑定
    off(name: string, fn: Function) {
        let eventName = this.list[name]
        if (eventName && fn) {
            let index = eventName.findIndex(fnItem => fnItem === fn)
            eventName.splice(index, 1)
        } else {
            console.error('没有找到对应的监听事件')
        }
    }

    // 一次性订阅
    once(name: string, fn: Function) {
        let decorator = (...args: Array<any>) => {
            fn.apply(this, args)
            this.off(name, decorator)
        }
        this.on(name, decorator)
    }
}

const o = new Dispatch()

// 订阅事件 'abc'，输出参数
o.on('abc', (...arg: Array<any>) => {
    console.log(arg)
})

// 一次性订阅事件 'abc'，输出参数和字符串 'once'，只会触发一次
o.once('abc', (...arg: Array<any>) => {
    console.log(arg, 'once')
})

// 发布事件 'abc'，输出参数 1、小诺、小诺
o.emit('abc', 1, "小诺", "小诺")

// 再次发布事件 'abc'，输出参数  2、小诺、小诺
o.emit('abc', 2, "小诺", "小诺")
```

## ["1","2","3"].map(parseInt)的输出结果是多少?parseInt第二个参数的作用是什么?

```javascript
console.log(["1", "2", "3"].map(parseInt))
```

parseInt方法接收两个参数，第一个参数为要被解析的字符串，而已知map会传递的参数是(item,index,arr)这种结构，
因此parseInt会接收到三组数据"1" 0, "2" 1 , "3":2,parseInt第二个参数是解析数字的基数，如果不传或传0则默认
为10进制，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN，因此第二组数据返回NaN,第三组数据指定为2进制
但第一个参数确是3，不满足二进制只有0、1的条件，因此也返回NaN，所有`正确答案是[1、NaN、NaN]`

## Object.is和===有哪些区别?他们各自的判断规则是什么?

```javascript
let obj1 = {}
let obj2 = {}
console.log(obj1 == obj2)
console.log(obj1 === obj2)
console.log(Object.is(obj1, obj2))
```

### 非严格相等的隐式类型转化规则

```javascript
//特殊情况1
console.log(null == undefined) //true
//特性情况2
console.log(NaN == "xiaonuo") // false
console.log(NaN == NaN) // false
```

相等比较(==)

1.如果两个操作数类型相同，执行严格比较。

2.如果两个操作数类型不同，则进行**类型转换**后再进行比较，规则如下：

- 如果一个操作数是数值(number),另一个操作数是字符串，则将**字符串转换为数值**，然后进行比较。
- 如果一个操作数是布尔值，则将**布尔值转换为数值**，然后进行比较。
- 如果一个操作数是对象，另一个操作数是数值或字符串，则将**对象转换为原始值**，然后比较。

关于将对象转换为原始值，如果一个操作数是对象，另一个操作数是字符串或者数字，会首先调用对象的valueOf()方法，将对象转化为基本类型，再进行比较，当valueOf()返回的不是基本类型的
时候，才会调用toString()方法，示例如下。

```javascript
let obj1 = {
    valueOf() {
        return 1
    },
    toString() {
        return "2"
    }
}

console.log(obj1 == "2") //false
console.log(obj1 == 1) // true

let obj2 = {
    valueOf() {
        return {}
    },
    toString() {
        return "2"
    }
}

console.log(obj2 == "2") //true
console.log(obj2 == 1) // false

```

### Object.is 和 === 的规则

Object.is 和 === 再比较两个值时**都不会进行类型转换**

Object.is :

- 当比较NaN时，Object.is(NaN,NaN)返回true
- 当比较+0和-0时，Object.is(+0,-0)返回false,它能区分正零和负零(如果要区分正负应使用Object.is)

=== :

- NaN === NaN返回false,因为NaN是不等于任何值，包括它自己
- 对于+0和-0，+0 === -0返回true，因为**严格相等不区分正负**

## 连续赋值的计算规则是什么?这段代码的输出结果是什么

赋值的返回结果就是你赋的值

```javascript
var obj1 = {age: 18}
var obj2 = obj1
obj1.prop = obj1 = {age: 19}
console.log(obj1)//{age:19}
console.log(obj2)//{age:18,prop:{age:19}}
``` 

## 如何实现数组索引的累加?考察对Proxy对象的理解

```javascript
const obj = {sum: 0}
const add = new Proxy(obj, {
    get: function (target, prop, receiver) {
        // 如果add对象和数字相加，则把目标对象的obj的sum和数字相加
        // 如果访问add对象的索引，则把当前索引累积到sum中
        if (prop === Symbol.toPrimitive) {
            const ret = target.sum
            target.sum = 0
            return () => ret
        } else {
            const sum = (target.sum || 0) + Number(prop)
            target.sum = sum
            return receiver
        }
    }
})

const result1 = add[1][2] + 3 //6
const result2 = add[3][4][5] + 6 //18

console.log(result1, result2)
```

## 求最长递增子序列(LIS)

```javascript
 function LTS(nums) {
    if (nums.length === 0) return []
    const result = [[nums[0]]]
    for (let i = 0; i < nums.length; i++) {
        const n = nums[i]
        update(n)
    }

    function update(n) {
        for (let i = result.length - 1; i >= 0; i--) {
            const line = result[i]
            const tail = line[line.length - 1]
            if (n > tail) {
                result[i + 1] = [...line, n]
                break;
            } else if (n < tail && i === 0) {
                result[i] = [n]
            }
        }
    }

    return result[result.length - 1]
}

console.log(LTS([4, 5, 1, 2, 7, 3, 6, 9]))
```