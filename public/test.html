<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: grid;
        place-items: center;
    }

    .parent {
        width: 100%;
        height: auto;
        box-sizing: border-box;
        padding: 20px 0px;
        border: 4px dashed orangered;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .child {
        width: 25%;
        height: 300px;
        background: linear-gradient(red, orange);
        margin-right: 5%;
        opacity: 0;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }

    .child:nth-child(1) {
        animation: fadeIn .5s 1s ease-in;
        animation-fill-mode: forwards;
    }

    .child:nth-child(2) {
        animation: fadeIn .5s 2s ease-in;
        animation-fill-mode: forwards;
    }

    .child:nth-child(3) {
        animation: fadeIn .5s 3s ease-in;
        margin-right: 0;
        animation-fill-mode: forwards;
    }
</style>
<body>
<div class="parent">
    <div class="child"></div>
    <div class="child"></div>
    <div class="child"></div>
</div>
<script>
    class WxxMitt {
        list

        constructor() {
            this.list = {}
        }

        emit(eventName, ...args) {
            let callbackList = this.list[eventName] || []
            if (callbackList?.length) {
                callbackList.forEach(callbackItem => {
                    callbackItem(...args)
                })
            } else {
                throw new Error("该订阅事件不存在")
            }
        }

        on(eventName, callback) {
            //注册函数
            this.list[eventName]?.length ? this.list[eventName].push(callback) : this.list[eventName] = [callback]
        }

        remove(eventName, callback) {
            let callbackList = this.list[eventName] || []
            if (callbackList?.length) {
                this.list[eventName] = callbackList.filter(callbackItem => callbackItem !== callback)
            } else {
                throw new Error("该订阅事件不存在")
            }
        }
    }

    let wxxMitt = new WxxMitt()

    const xiaonuo = (...args) => {
        console.log("我订阅了小诺说的话", args)
    }

    const xiaonuo2 = (...args) => {
        console.log("我订阅了小诺说的第二次话", args)
    }

    //订阅
    wxxMitt.on("xiaonuo", xiaonuo)
    wxxMitt.on("xiaonuo", xiaonuo2)
    //触发
    wxxMitt.emit("xiaonuo", "小诺", "你", "今天", "吃了什么")
    wxxMitt.emit("xiaonuo", "小诺", "你", "睡了吗")
    //移除
    wxxMitt.remove("xiaonuo", xiaonuo)
    wxxMitt.remove("xiaonuo", xiaonuo2)
    //再次触发报错
    //wxxMitt.emit("xiaonuo", "小诺", "你", "今天", "吃了什么")


    function getMaxRevenue(plots, n) {
        //数据拆分
        let oilList = []
        let revenueList = []
        plots.forEach(item => {
            oilList.push(item[0])
            revenueList.push(item[1])
        })
        // 初始化dp数组，大小为n+1，初始值为-1,代表从0开始每一个油的刻度都应该有一个最大收益
        const dp = new Array(n + 1).fill(0);
        dp[0] = 0;
        //循环地块列表
        for (let i = 0; i < oilList.length; i++) {
            //循环耗油量，满足剩余油限制
            console.log("第" + i + "轮地皮循环前收益", dp)
            for (let j = n; j >= oilList[i]; j--) {
                if (dp[j] < dp[j - oilList[i]] + revenueList[i]) {
                    dp[j] = dp[j - oilList[i]] + revenueList[i]
                }
            }
            console.log("第" + i + "轮地皮循环后收益", dp)
        }
        return dp[n]
    }

    const plots = [[1, 1], [2, 4], [3, 5], [7, 9], [6, 10], [6, 10]]
    const n = 10
    console.log(getMaxRevenue(plots, n))


    class TaskScheduler {
        jobArray

        constructor() {
            this.jobArray = {}
        }
    }

    function LTS(nums) {
        if (nums.length === 0) return []
        const result = [[nums[0]]]
        for (let i = 0; i < nums.length; i++) {
            const n = nums[i]
            update(n)
        }

        function update(n) {
            for (let i = result.length - 1; i >= 0; i--) {
                const line = result[i]
                const tail = line[line.length - 1]
                if (n > tail) {
                    result[i + 1] = [...line, n]
                    break;
                } else if (n < tail && i === 0) {
                    result[i] = [n]
                }
            }
        }

        return result[result.length - 1]
    }

    console.log(LTS([4, 5, 1, 2, 7, 3, 6, 9]))
</script>
</body>
</html>